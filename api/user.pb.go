// Code generated by protoc-gen-go.
// source: user.proto
// DO NOT EDIT!

package api

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/grpc-ecosystem/grpc-gateway/third_party/googleapis/google/api"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Defines the applications that the user is associated with.
type ApplicationLink struct {
	ApplicationID   int64  `protobuf:"varint,1,opt,name=applicationID" json:"applicationID,omitempty"`
	ApplicationName string `protobuf:"bytes,2,opt,name=applicationName" json:"applicationName,omitempty"`
	IsAdmin         bool   `protobuf:"varint,3,opt,name=isAdmin" json:"isAdmin,omitempty"`
	CreatedAt       string `protobuf:"bytes,4,opt,name=createdAt" json:"createdAt,omitempty"`
	UpdatedAt       string `protobuf:"bytes,5,opt,name=updatedAt" json:"updatedAt,omitempty"`
}

func (m *ApplicationLink) Reset()                    { *m = ApplicationLink{} }
func (m *ApplicationLink) String() string            { return proto.CompactTextString(m) }
func (*ApplicationLink) ProtoMessage()               {}
func (*ApplicationLink) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{0} }

func (m *ApplicationLink) GetApplicationID() int64 {
	if m != nil {
		return m.ApplicationID
	}
	return 0
}

func (m *ApplicationLink) GetApplicationName() string {
	if m != nil {
		return m.ApplicationName
	}
	return ""
}

func (m *ApplicationLink) GetIsAdmin() bool {
	if m != nil {
		return m.IsAdmin
	}
	return false
}

func (m *ApplicationLink) GetCreatedAt() string {
	if m != nil {
		return m.CreatedAt
	}
	return ""
}

func (m *ApplicationLink) GetUpdatedAt() string {
	if m != nil {
		return m.UpdatedAt
	}
	return ""
}

// The user profile, indicating the capabilities of the user.
type UserProfile struct {
	Applications []*ApplicationLink `protobuf:"bytes,1,rep,name=applications" json:"applications,omitempty"`
}

func (m *UserProfile) Reset()                    { *m = UserProfile{} }
func (m *UserProfile) String() string            { return proto.CompactTextString(m) }
func (*UserProfile) ProtoMessage()               {}
func (*UserProfile) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{1} }

func (m *UserProfile) GetApplications() []*ApplicationLink {
	if m != nil {
		return m.Applications
	}
	return nil
}

// The request for profile requires not input as the profile is returned for
// the logged in user based on the JWT token passed in.
type ProfileRequest struct {
}

func (m *ProfileRequest) Reset()                    { *m = ProfileRequest{} }
func (m *ProfileRequest) String() string            { return proto.CompactTextString(m) }
func (*ProfileRequest) ProtoMessage()               {}
func (*ProfileRequest) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{2} }

// The user's profile. This specifies the access the user has to the data
// and should be used limit what the UI presents as options (e.g., read-only
// access to an application should not allow an "edit" button on that
// application).
type ProfileResponse struct {
	UserProfile *UserProfile `protobuf:"bytes,1,opt,name=userProfile" json:"userProfile,omitempty"`
}

func (m *ProfileResponse) Reset()                    { *m = ProfileResponse{} }
func (m *ProfileResponse) String() string            { return proto.CompactTextString(m) }
func (*ProfileResponse) ProtoMessage()               {}
func (*ProfileResponse) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{3} }

func (m *ProfileResponse) GetUserProfile() *UserProfile {
	if m != nil {
		return m.UserProfile
	}
	return nil
}

// The data for logging in to the system.  The connection is expected to be
// protected by SSL, allowing us to use the username and password in the clear.
type LoginRequest struct {
	// Username of the user.
	Username string `protobuf:"bytes,1,opt,name=username" json:"username,omitempty"`
	// Password of the user.
	Password string `protobuf:"bytes,2,opt,name=password" json:"password,omitempty"`
}

func (m *LoginRequest) Reset()                    { *m = LoginRequest{} }
func (m *LoginRequest) String() string            { return proto.CompactTextString(m) }
func (*LoginRequest) ProtoMessage()               {}
func (*LoginRequest) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{4} }

func (m *LoginRequest) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *LoginRequest) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

// The response to the login request upon success. The jwt token is to be
// placed in the header field named "Grpc-Metadata-Authorization" for all
// subsequent queries to the server.
type LoginResponse struct {
	// The JWT tag to be used to access lora-app-server interfaces.
	Jwt string `protobuf:"bytes,1,opt,name=jwt" json:"jwt,omitempty"`
	// The user's profile (provided as a convenience so an additional call to
	// get the profile can be avoided).
	Profile *ProfileResponse `protobuf:"bytes,2,opt,name=profile" json:"profile,omitempty"`
}

func (m *LoginResponse) Reset()                    { *m = LoginResponse{} }
func (m *LoginResponse) String() string            { return proto.CompactTextString(m) }
func (*LoginResponse) ProtoMessage()               {}
func (*LoginResponse) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{5} }

func (m *LoginResponse) GetJwt() string {
	if m != nil {
		return m.Jwt
	}
	return ""
}

func (m *LoginResponse) GetProfile() *ProfileResponse {
	if m != nil {
		return m.Profile
	}
	return nil
}

// Request the users defined in the system.
type ListUserRequest struct {
	// Max number of user to return in the result-set.
	Limit int32 `protobuf:"varint,1,opt,name=limit" json:"limit,omitempty"`
	// Offset in the result-set (for pagination).
	Offset int32 `protobuf:"varint,2,opt,name=offset" json:"offset,omitempty"`
}

func (m *ListUserRequest) Reset()                    { *m = ListUserRequest{} }
func (m *ListUserRequest) String() string            { return proto.CompactTextString(m) }
func (*ListUserRequest) ProtoMessage()               {}
func (*ListUserRequest) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{6} }

func (m *ListUserRequest) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *ListUserRequest) GetOffset() int32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

// Request the user information.
type UserRequest struct {
	Id int64 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
}

func (m *UserRequest) Reset()                    { *m = UserRequest{} }
func (m *UserRequest) String() string            { return proto.CompactTextString(m) }
func (*UserRequest) ProtoMessage()               {}
func (*UserRequest) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{7} }

func (m *UserRequest) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

type AddUserResponse struct {
	Id int64 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
}

func (m *AddUserResponse) Reset()                    { *m = AddUserResponse{} }
func (m *AddUserResponse) String() string            { return proto.CompactTextString(m) }
func (*AddUserResponse) ProtoMessage()               {}
func (*AddUserResponse) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{8} }

func (m *AddUserResponse) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

// User data not including the data access profile.
type UserSettings struct {
	// ID of the user.
	Id int64 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	// Username of the user.
	Username string `protobuf:"bytes,2,opt,name=username" json:"username,omitempty"`
	// The session timeout, in minutes.
	SessionTTL int32 `protobuf:"varint,3,opt,name=sessionTTL" json:"sessionTTL,omitempty"`
	// If the user is a system admin, capable of creating other users.
	IsAdmin bool `protobuf:"varint,4,opt,name=isAdmin" json:"isAdmin,omitempty"`
	// When the user was created.
	CreatedAt string `protobuf:"bytes,5,opt,name=createdAt" json:"createdAt,omitempty"`
	// When the user was last updated (excludes changes in application access).
	UpdatedAt string `protobuf:"bytes,6,opt,name=updatedAt" json:"updatedAt,omitempty"`
}

func (m *UserSettings) Reset()                    { *m = UserSettings{} }
func (m *UserSettings) String() string            { return proto.CompactTextString(m) }
func (*UserSettings) ProtoMessage()               {}
func (*UserSettings) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{9} }

func (m *UserSettings) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *UserSettings) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *UserSettings) GetSessionTTL() int32 {
	if m != nil {
		return m.SessionTTL
	}
	return 0
}

func (m *UserSettings) GetIsAdmin() bool {
	if m != nil {
		return m.IsAdmin
	}
	return false
}

func (m *UserSettings) GetCreatedAt() string {
	if m != nil {
		return m.CreatedAt
	}
	return ""
}

func (m *UserSettings) GetUpdatedAt() string {
	if m != nil {
		return m.UpdatedAt
	}
	return ""
}

// UserInfo includes the general login settings as well as the user profile.
type UserInfo struct {
	UserSettings *UserSettings `protobuf:"bytes,1,opt,name=userSettings" json:"userSettings,omitempty"`
	UserProfile  *UserProfile  `protobuf:"bytes,2,opt,name=userProfile" json:"userProfile,omitempty"`
}

func (m *UserInfo) Reset()                    { *m = UserInfo{} }
func (m *UserInfo) String() string            { return proto.CompactTextString(m) }
func (*UserInfo) ProtoMessage()               {}
func (*UserInfo) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{10} }

func (m *UserInfo) GetUserSettings() *UserSettings {
	if m != nil {
		return m.UserSettings
	}
	return nil
}

func (m *UserInfo) GetUserProfile() *UserProfile {
	if m != nil {
		return m.UserProfile
	}
	return nil
}

type UserResponse struct {
	// The user settings and profile.
	Info *UserInfo `protobuf:"bytes,1,opt,name=info" json:"info,omitempty"`
}

func (m *UserResponse) Reset()                    { *m = UserResponse{} }
func (m *UserResponse) String() string            { return proto.CompactTextString(m) }
func (*UserResponse) ProtoMessage()               {}
func (*UserResponse) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{11} }

func (m *UserResponse) GetInfo() *UserInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

// Add a new user. Not quite the UserSettings data as it includes a password
// and excludes the ID and create/update dates.
type AddUserRequest struct {
	// Username of the user.
	Username string `protobuf:"bytes,1,opt,name=username" json:"username,omitempty"`
	// Passowrd of the user.
	Password string `protobuf:"bytes,2,opt,name=password" json:"password,omitempty"`
	// The session timeout, in minutes.
	SessionTTL int32 `protobuf:"varint,3,opt,name=sessionTTL" json:"sessionTTL,omitempty"`
	// If the user is a system-wide admin.
	IsAdmin bool `protobuf:"varint,4,opt,name=isAdmin" json:"isAdmin,omitempty"`
}

func (m *AddUserRequest) Reset()                    { *m = AddUserRequest{} }
func (m *AddUserRequest) String() string            { return proto.CompactTextString(m) }
func (*AddUserRequest) ProtoMessage()               {}
func (*AddUserRequest) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{12} }

func (m *AddUserRequest) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *AddUserRequest) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *AddUserRequest) GetSessionTTL() int32 {
	if m != nil {
		return m.SessionTTL
	}
	return 0
}

func (m *AddUserRequest) GetIsAdmin() bool {
	if m != nil {
		return m.IsAdmin
	}
	return false
}

// Not quite the AddUserRequest as no password.
type UpdateUserRequest struct {
	// The ID of the user to be updated.
	Id int64 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	// The new username.
	Username string `protobuf:"bytes,2,opt,name=username" json:"username,omitempty"`
	// The session timeout, in minutes.
	SessionTTL int32 `protobuf:"varint,3,opt,name=sessionTTL" json:"sessionTTL,omitempty"`
	// If the user is a system-wide admin.
	IsAdmin bool `protobuf:"varint,4,opt,name=isAdmin" json:"isAdmin,omitempty"`
}

func (m *UpdateUserRequest) Reset()                    { *m = UpdateUserRequest{} }
func (m *UpdateUserRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdateUserRequest) ProtoMessage()               {}
func (*UpdateUserRequest) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{13} }

func (m *UpdateUserRequest) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *UpdateUserRequest) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *UpdateUserRequest) GetSessionTTL() int32 {
	if m != nil {
		return m.SessionTTL
	}
	return 0
}

func (m *UpdateUserRequest) GetIsAdmin() bool {
	if m != nil {
		return m.IsAdmin
	}
	return false
}

type ListUserResponse struct {
	TotalCount int32           `protobuf:"varint,1,opt,name=totalCount" json:"totalCount,omitempty"`
	Users      []*UserResponse `protobuf:"bytes,2,rep,name=users" json:"users,omitempty"`
}

func (m *ListUserResponse) Reset()                    { *m = ListUserResponse{} }
func (m *ListUserResponse) String() string            { return proto.CompactTextString(m) }
func (*ListUserResponse) ProtoMessage()               {}
func (*ListUserResponse) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{14} }

func (m *ListUserResponse) GetTotalCount() int32 {
	if m != nil {
		return m.TotalCount
	}
	return 0
}

func (m *ListUserResponse) GetUsers() []*UserResponse {
	if m != nil {
		return m.Users
	}
	return nil
}

type UserEmptyResponse struct {
}

func (m *UserEmptyResponse) Reset()                    { *m = UserEmptyResponse{} }
func (m *UserEmptyResponse) String() string            { return proto.CompactTextString(m) }
func (*UserEmptyResponse) ProtoMessage()               {}
func (*UserEmptyResponse) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{15} }

type UpdateUserPasswordRequest struct {
	// The ID of the user for which to update the password.
	Id int64 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	// The new password to set.
	Password string `protobuf:"bytes,2,opt,name=password" json:"password,omitempty"`
}

func (m *UpdateUserPasswordRequest) Reset()                    { *m = UpdateUserPasswordRequest{} }
func (m *UpdateUserPasswordRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdateUserPasswordRequest) ProtoMessage()               {}
func (*UpdateUserPasswordRequest) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{16} }

func (m *UpdateUserPasswordRequest) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *UpdateUserPasswordRequest) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func init() {
	proto.RegisterType((*ApplicationLink)(nil), "api.ApplicationLink")
	proto.RegisterType((*UserProfile)(nil), "api.UserProfile")
	proto.RegisterType((*ProfileRequest)(nil), "api.ProfileRequest")
	proto.RegisterType((*ProfileResponse)(nil), "api.ProfileResponse")
	proto.RegisterType((*LoginRequest)(nil), "api.LoginRequest")
	proto.RegisterType((*LoginResponse)(nil), "api.LoginResponse")
	proto.RegisterType((*ListUserRequest)(nil), "api.ListUserRequest")
	proto.RegisterType((*UserRequest)(nil), "api.UserRequest")
	proto.RegisterType((*AddUserResponse)(nil), "api.AddUserResponse")
	proto.RegisterType((*UserSettings)(nil), "api.UserSettings")
	proto.RegisterType((*UserInfo)(nil), "api.UserInfo")
	proto.RegisterType((*UserResponse)(nil), "api.UserResponse")
	proto.RegisterType((*AddUserRequest)(nil), "api.AddUserRequest")
	proto.RegisterType((*UpdateUserRequest)(nil), "api.UpdateUserRequest")
	proto.RegisterType((*ListUserResponse)(nil), "api.ListUserResponse")
	proto.RegisterType((*UserEmptyResponse)(nil), "api.UserEmptyResponse")
	proto.RegisterType((*UpdateUserPasswordRequest)(nil), "api.UpdateUserPasswordRequest")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for User service

type UserClient interface {
	// Get user list.
	List(ctx context.Context, in *ListUserRequest, opts ...grpc.CallOption) (*ListUserResponse, error)
	// Get data for a particular user.
	Get(ctx context.Context, in *UserRequest, opts ...grpc.CallOption) (*UserResponse, error)
	// Create a new user.
	Create(ctx context.Context, in *AddUserRequest, opts ...grpc.CallOption) (*AddUserResponse, error)
	// Update an existing user.
	Update(ctx context.Context, in *UpdateUserRequest, opts ...grpc.CallOption) (*UserEmptyResponse, error)
	// Delete a user.
	Delete(ctx context.Context, in *UserRequest, opts ...grpc.CallOption) (*UserEmptyResponse, error)
	// UpdatePassword updates a password.
	UpdatePassword(ctx context.Context, in *UpdateUserPasswordRequest, opts ...grpc.CallOption) (*UserEmptyResponse, error)
}

type userClient struct {
	cc *grpc.ClientConn
}

func NewUserClient(cc *grpc.ClientConn) UserClient {
	return &userClient{cc}
}

func (c *userClient) List(ctx context.Context, in *ListUserRequest, opts ...grpc.CallOption) (*ListUserResponse, error) {
	out := new(ListUserResponse)
	err := grpc.Invoke(ctx, "/api.User/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) Get(ctx context.Context, in *UserRequest, opts ...grpc.CallOption) (*UserResponse, error) {
	out := new(UserResponse)
	err := grpc.Invoke(ctx, "/api.User/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) Create(ctx context.Context, in *AddUserRequest, opts ...grpc.CallOption) (*AddUserResponse, error) {
	out := new(AddUserResponse)
	err := grpc.Invoke(ctx, "/api.User/Create", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) Update(ctx context.Context, in *UpdateUserRequest, opts ...grpc.CallOption) (*UserEmptyResponse, error) {
	out := new(UserEmptyResponse)
	err := grpc.Invoke(ctx, "/api.User/Update", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) Delete(ctx context.Context, in *UserRequest, opts ...grpc.CallOption) (*UserEmptyResponse, error) {
	out := new(UserEmptyResponse)
	err := grpc.Invoke(ctx, "/api.User/Delete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) UpdatePassword(ctx context.Context, in *UpdateUserPasswordRequest, opts ...grpc.CallOption) (*UserEmptyResponse, error) {
	out := new(UserEmptyResponse)
	err := grpc.Invoke(ctx, "/api.User/UpdatePassword", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for User service

type UserServer interface {
	// Get user list.
	List(context.Context, *ListUserRequest) (*ListUserResponse, error)
	// Get data for a particular user.
	Get(context.Context, *UserRequest) (*UserResponse, error)
	// Create a new user.
	Create(context.Context, *AddUserRequest) (*AddUserResponse, error)
	// Update an existing user.
	Update(context.Context, *UpdateUserRequest) (*UserEmptyResponse, error)
	// Delete a user.
	Delete(context.Context, *UserRequest) (*UserEmptyResponse, error)
	// UpdatePassword updates a password.
	UpdatePassword(context.Context, *UpdateUserPasswordRequest) (*UserEmptyResponse, error)
}

func RegisterUserServer(s *grpc.Server, srv UserServer) {
	s.RegisterService(&_User_serviceDesc, srv)
}

func _User_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.User/List",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).List(ctx, req.(*ListUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.User/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).Get(ctx, req.(*UserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.User/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).Create(ctx, req.(*AddUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.User/Update",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).Update(ctx, req.(*UpdateUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.User/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).Delete(ctx, req.(*UserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_UpdatePassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserPasswordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).UpdatePassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.User/UpdatePassword",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).UpdatePassword(ctx, req.(*UpdateUserPasswordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _User_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.User",
	HandlerType: (*UserServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "List",
			Handler:    _User_List_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _User_Get_Handler,
		},
		{
			MethodName: "Create",
			Handler:    _User_Create_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _User_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _User_Delete_Handler,
		},
		{
			MethodName: "UpdatePassword",
			Handler:    _User_UpdatePassword_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "user.proto",
}

// Client API for Internal service

type InternalClient interface {
	// Log in a user
	Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error)
	// Get the current user's profile
	Profile(ctx context.Context, in *ProfileRequest, opts ...grpc.CallOption) (*ProfileResponse, error)
}

type internalClient struct {
	cc *grpc.ClientConn
}

func NewInternalClient(cc *grpc.ClientConn) InternalClient {
	return &internalClient{cc}
}

func (c *internalClient) Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error) {
	out := new(LoginResponse)
	err := grpc.Invoke(ctx, "/api.Internal/Login", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalClient) Profile(ctx context.Context, in *ProfileRequest, opts ...grpc.CallOption) (*ProfileResponse, error) {
	out := new(ProfileResponse)
	err := grpc.Invoke(ctx, "/api.Internal/Profile", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Internal service

type InternalServer interface {
	// Log in a user
	Login(context.Context, *LoginRequest) (*LoginResponse, error)
	// Get the current user's profile
	Profile(context.Context, *ProfileRequest) (*ProfileResponse, error)
}

func RegisterInternalServer(s *grpc.Server, srv InternalServer) {
	s.RegisterService(&_Internal_serviceDesc, srv)
}

func _Internal_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalServer).Login(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Internal/Login",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalServer).Login(ctx, req.(*LoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Internal_Profile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProfileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalServer).Profile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Internal/Profile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalServer).Profile(ctx, req.(*ProfileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Internal_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.Internal",
	HandlerType: (*InternalServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Login",
			Handler:    _Internal_Login_Handler,
		},
		{
			MethodName: "Profile",
			Handler:    _Internal_Profile_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "user.proto",
}

func init() { proto.RegisterFile("user.proto", fileDescriptor5) }

var fileDescriptor5 = []byte{
	// 787 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x56, 0xdd, 0x6e, 0xdb, 0x36,
	0x14, 0x86, 0x64, 0xcb, 0x71, 0x8e, 0x1d, 0xff, 0xd0, 0xf9, 0xd1, 0xb4, 0x24, 0x70, 0x88, 0x01,
	0x33, 0x76, 0x61, 0x63, 0x1e, 0x06, 0xec, 0x6e, 0x30, 0x92, 0xcc, 0x08, 0x62, 0x0c, 0x89, 0x92,
	0x5c, 0xed, 0x4a, 0x8b, 0x68, 0x83, 0x99, 0x2c, 0x6a, 0x26, 0x8d, 0x20, 0x28, 0x7a, 0x93, 0x57,
	0xe8, 0x6b, 0xf4, 0xa2, 0x77, 0x7d, 0x90, 0xbe, 0x42, 0x6f, 0xfa, 0x16, 0x85, 0x48, 0x4a, 0x96,
	0x94, 0xc6, 0x2d, 0x5a, 0xf4, 0xce, 0x3c, 0xe7, 0xf0, 0x3b, 0xdf, 0xf9, 0xf8, 0x51, 0x34, 0xc0,
	0x92, 0x93, 0x45, 0x3f, 0x5a, 0x30, 0xc1, 0x50, 0xc9, 0x8b, 0xa8, 0xb3, 0x3f, 0x63, 0x6c, 0x16,
	0x90, 0x81, 0x17, 0xd1, 0x81, 0x17, 0x86, 0x4c, 0x78, 0x82, 0xb2, 0x90, 0xab, 0x12, 0xfc, 0xd6,
	0x80, 0xe6, 0x28, 0x8a, 0x02, 0x7a, 0x2b, 0xc3, 0x13, 0x1a, 0xfe, 0x87, 0x7e, 0x82, 0x2d, 0x6f,
	0x15, 0x3a, 0x3b, 0xb1, 0x8d, 0xae, 0xd1, 0x2b, 0xb9, 0xf9, 0x20, 0xea, 0x41, 0x33, 0x13, 0xf8,
	0xdb, 0x9b, 0x13, 0xdb, 0xec, 0x1a, 0xbd, 0x4d, 0xb7, 0x18, 0x46, 0x36, 0x6c, 0x50, 0x3e, 0xf2,
	0xe7, 0x34, 0xb4, 0x4b, 0x5d, 0xa3, 0x57, 0x75, 0x93, 0x25, 0xda, 0x87, 0xcd, 0xdb, 0x05, 0xf1,
	0x04, 0xf1, 0x47, 0xc2, 0x2e, 0xcb, 0xdd, 0xab, 0x40, 0x9c, 0x5d, 0x46, 0xbe, 0xce, 0x5a, 0x2a,
	0x9b, 0x06, 0xf0, 0x18, 0x6a, 0x37, 0x9c, 0x2c, 0x2e, 0x16, 0x6c, 0x4a, 0x03, 0x82, 0xfe, 0x80,
	0x7a, 0xa6, 0x2f, 0xb7, 0x8d, 0x6e, 0xa9, 0x57, 0x1b, 0x6e, 0xf7, 0xbd, 0x88, 0xf6, 0x0b, 0x03,
	0xba, 0xb9, 0x4a, 0xdc, 0x82, 0x86, 0x06, 0x71, 0xc9, 0xff, 0x4b, 0xc2, 0x05, 0x3e, 0x85, 0x66,
	0x1a, 0xe1, 0x11, 0x0b, 0x39, 0x41, 0x43, 0xa8, 0x2d, 0x57, 0xdd, 0xa4, 0x22, 0xb5, 0x61, 0x4b,
	0xa2, 0x67, 0x58, 0xb8, 0xd9, 0x22, 0xfc, 0x17, 0xd4, 0x27, 0x6c, 0x46, 0x43, 0x0d, 0x8b, 0x1c,
	0xa8, 0xc6, 0xe9, 0x30, 0x96, 0xca, 0x90, 0xe3, 0xa4, 0xeb, 0x38, 0x17, 0x79, 0x9c, 0xdf, 0xb3,
	0x85, 0xaf, 0x65, 0x4c, 0xd7, 0xf8, 0x12, 0xb6, 0x34, 0x8e, 0x26, 0xd3, 0x82, 0xd2, 0xdd, 0xbd,
	0xd0, 0x18, 0xf1, 0x4f, 0xd4, 0x87, 0x8d, 0x48, 0x53, 0x33, 0x25, 0x35, 0x35, 0x78, 0x61, 0x0a,
	0x37, 0x29, 0xc2, 0x7f, 0x42, 0x73, 0x42, 0xb9, 0x88, 0xa9, 0x27, 0xec, 0xb6, 0xc1, 0x0a, 0xe8,
	0x9c, 0x2a, 0x58, 0xcb, 0x55, 0x0b, 0xb4, 0x0b, 0x15, 0x36, 0x9d, 0x72, 0x22, 0x24, 0xae, 0xe5,
	0xea, 0x15, 0x3e, 0x50, 0xea, 0x27, 0x9b, 0x1b, 0x60, 0x52, 0x5f, 0xfb, 0xc4, 0xa4, 0x3e, 0x3e,
	0x82, 0xe6, 0xc8, 0xf7, 0x55, 0x85, 0x26, 0x5d, 0x2c, 0x79, 0x63, 0x40, 0x3d, 0x2e, 0xb8, 0x22,
	0x42, 0xd0, 0x70, 0xc6, 0x8b, 0x05, 0x39, 0xb9, 0xcc, 0x82, 0x5c, 0x87, 0x00, 0x9c, 0x70, 0x4e,
	0x59, 0x78, 0x7d, 0x3d, 0x91, 0xae, 0xb2, 0xdc, 0x4c, 0x24, 0x6b, 0xb9, 0xf2, 0x1a, 0xcb, 0x59,
	0x6b, 0x2d, 0x57, 0x29, 0x5a, 0x6e, 0x09, 0xd5, 0x98, 0xf1, 0x59, 0x38, 0x65, 0xe8, 0x77, 0xa8,
	0x2f, 0x33, 0xec, 0xb5, 0x23, 0xda, 0xa9, 0x23, 0x92, 0x84, 0x9b, 0x2b, 0x2b, 0xfa, 0xc8, 0xfc,
	0x12, 0x1f, 0xfd, 0xaa, 0x84, 0x4a, 0x95, 0x3c, 0x82, 0x32, 0x0d, 0xa7, 0x4c, 0xb7, 0xdc, 0x4a,
	0x37, 0xc7, 0xbc, 0x5c, 0x99, 0xc2, 0x8f, 0x06, 0x34, 0xd2, 0x03, 0xf8, 0x26, 0xf7, 0x7d, 0xbd,
	0xd4, 0xf8, 0x01, 0xda, 0x37, 0x52, 0xbb, 0x35, 0x4e, 0xf9, 0x3e, 0xa7, 0x8c, 0xff, 0x81, 0xd6,
	0xca, 0xdf, 0x5a, 0xb6, 0x43, 0x00, 0xc1, 0x84, 0x17, 0x1c, 0xb3, 0x65, 0x98, 0xb8, 0x3c, 0x13,
	0x41, 0x3f, 0x83, 0x15, 0x77, 0xe6, 0xb6, 0x29, 0x3f, 0x1d, 0xab, 0xa3, 0x4c, 0xaf, 0x8f, 0xca,
	0xe3, 0x0e, 0xb4, 0xe3, 0xf0, 0xe9, 0x3c, 0x12, 0x0f, 0x49, 0x0e, 0x8f, 0xe1, 0x87, 0xd5, 0xb0,
	0x17, 0x5a, 0xbc, 0x35, 0x43, 0x3f, 0xa7, 0xf7, 0xf0, 0x43, 0x09, 0xca, 0x31, 0x06, 0x1a, 0x43,
	0x39, 0x9e, 0x01, 0xa9, 0xab, 0x5c, 0xb8, 0xae, 0xce, 0x4e, 0x21, 0xaa, 0x69, 0xa0, 0xc7, 0x77,
	0xef, 0x5f, 0x99, 0x75, 0x04, 0xf2, 0x7b, 0x2f, 0xf9, 0xa2, 0x63, 0x28, 0x8d, 0x89, 0x40, 0xad,
	0xcc, 0x40, 0x0a, 0xe3, 0xe9, 0x88, 0x78, 0x4f, 0xee, 0x6f, 0xa3, 0xe6, 0x6a, 0xff, 0xe0, 0x05,
	0xf5, 0x5f, 0xa2, 0x31, 0x54, 0x8e, 0xe5, 0x35, 0x41, 0x1d, 0xf5, 0x4d, 0xcd, 0xb9, 0xcb, 0xd9,
	0xce, 0x07, 0xf3, 0x6c, 0x70, 0x96, 0xcd, 0x25, 0x54, 0x94, 0x50, 0x68, 0x57, 0xb5, 0x2f, 0x5a,
	0xc4, 0xd9, 0x4d, 0x69, 0xe5, 0x25, 0xd6, 0xdc, 0x9c, 0x27, 0xdc, 0xce, 0xa1, 0x72, 0x42, 0x02,
	0x22, 0xc8, 0x27, 0x66, 0xfc, 0x0c, 0xd8, 0x2f, 0x4f, 0xc0, 0xee, 0xa0, 0xa1, 0x28, 0x5d, 0xa4,
	0x37, 0xa0, 0xc0, 0xb3, 0x70, 0xba, 0xcf, 0xb6, 0xe8, 0xca, 0x16, 0x8e, 0x63, 0x17, 0x5a, 0x0c,
	0xd2, 0xb3, 0x7e, 0x6d, 0x40, 0xf5, 0x2c, 0x14, 0xb1, 0xdd, 0x03, 0x74, 0x0e, 0x96, 0xfc, 0xcc,
	0x23, 0x75, 0x2c, 0xd9, 0xa7, 0xc3, 0x41, 0xd9, 0x90, 0x86, 0xff, 0x51, 0xc2, 0xef, 0xe0, 0x8e,
	0x84, 0xa7, 0x1a, 0x66, 0x10, 0x48, 0x8c, 0x2b, 0xd8, 0x48, 0x5e, 0xc6, 0x4e, 0xfe, 0x29, 0xc8,
	0x9e, 0x57, 0xe1, 0x7d, 0xc0, 0x07, 0x12, 0x72, 0x0f, 0xed, 0xe4, 0x21, 0xf5, 0xab, 0xf1, 0x6f,
	0x45, 0xfe, 0x67, 0xf8, 0xed, 0x63, 0x00, 0x00, 0x00, 0xff, 0xff, 0x85, 0x34, 0xa8, 0x30, 0x64,
	0x08, 0x00, 0x00,
}
